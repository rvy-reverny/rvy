# {{Name}} - Clean Architecture with Database Adapters

This code was generated by `rvy` CLI tool.

## Architecture Overview

```
Service Layer (Business Logic Interface)
    ↓
Usecase Layer (Application Logic)
    ↓
Repository Trait (Abstraction)
    ↓
Adapters (Postgres, MySQL, MongoDB, SQLite)
```

## Setup

### 1. Update Cargo.toml

Uncomment the database dependencies you need:

```toml
[dependencies]
# For Postgres
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "postgres", "chrono"] }

# For MySQL
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "mysql", "chrono"] }

# For MongoDB
mongodb = "3.1"

# For SQLite
sqlx = { version = "0.8", features = ["runtime-tokio-rustls", "sqlite", "chrono"] }
```

### 2. Set Environment Variables

Create a `.env` file:

```bash
# For Postgres
DATABASE_TYPE=postgres
DATABASE_URL=postgresql://user:password@localhost/dbname

# For MySQL
DATABASE_TYPE=mysql
DATABASE_URL=mysql://user:password@localhost/dbname

# For MongoDB
DATABASE_TYPE=mongodb
DATABASE_URL=mongodb://localhost:27017

# For SQLite
DATABASE_TYPE=sqlite
DATABASE_URL=sqlite://./database.db
```

### 3. Run Migrations (for SQL databases)

```bash
# Create migration
sqlx migrate add create_{{name}}s_table

# Write migration SQL (example for Postgres)
# migrations/xxx_create_{{name}}s_table.sql
CREATE TABLE {{name}}s (
    id BIGINT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE,
    updated_at TIMESTAMP WITH TIME ZONE
);

# Run migrations
sqlx migrate run
```

## Usage

### Basic Example

```rust
use std::sync::Arc;
use config::database::DatabaseConfig;
use factory::{{name}}_factory::create_{{name}}_repository;
use usecase::{{name}}_usecase::{{Name}}Usecase;
use service::{{name}}_service::{{Name}}Service;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Load config from environment
    let config = DatabaseConfig::from_env();
    
    // Create repository (automatically selects correct adapter)
    let repository = create_{{name}}_repository(&config).await?;
    
    // Create usecase and service
    let usecase = Arc::new({{Name}}Usecase::new(repository));
    let service = {{Name}}Service::new(usecase);

    // Use the service
    let item = service.get_by_id(1).await?;
    println!("{:?}", item);

    Ok(())
}
```

## Switching Databases

To switch databases, just change the environment variables - **no code changes needed**:

```bash
# Switch to MongoDB
export DATABASE_TYPE=mongodb
export DATABASE_URL=mongodb://localhost:27017

# Or switch to SQLite
export DATABASE_TYPE=sqlite
export DATABASE_URL=sqlite://./data.db
```

The factory pattern automatically creates the correct adapter!

## Testing with Different Databases

```bash
# Test with Postgres
DATABASE_TYPE=postgres DATABASE_URL=postgresql://localhost/test cargo run

# Test with MySQL
DATABASE_TYPE=mysql DATABASE_URL=mysql://localhost/test cargo run

# Test with MongoDB
DATABASE_TYPE=mongodb DATABASE_URL=mongodb://localhost:27017 cargo run

# Test with SQLite
DATABASE_TYPE=sqlite DATABASE_URL=sqlite://./test.db cargo run
```

## Adding Custom Business Logic

Add your business logic in the **Usecase layer**:

```rust
impl {{Name}}Usecase {
    pub async fn create(&self, data: {{Name}}Data) -> Result<{{Name}}Data, Box<dyn std::error::Error>> {
        // Validate
        if data.name.is_empty() {
            return Err("Name cannot be empty".into());
        }

        // Business rules
        if data.name.len() < 3 {
            return Err("Name must be at least 3 characters".into());
        }

        // Save
        self.repository.save(&data).await
    }
}
```

## Generated Files

- `src/service/{{name}}_service.rs` - Service layer (API interface)
- `src/usecase/{{name}}_usecase.rs` - Business logic layer
- `src/repository/{{name}}.rs` - Repository trait (interface)
- `src/data/{{name}}_data.rs` - Data model
- `src/adapter/{{name}}_postgres.rs` - Postgres implementation
- `src/adapter/{{name}}_mysql.rs` - MySQL implementation
- `src/adapter/{{name}}_mongodb.rs` - MongoDB implementation
- `src/adapter/{{name}}_sqlite.rs` - SQLite implementation
- `src/config/database.rs` - Database configuration
- `src/factory/{{name}}_factory.rs` - Factory for creating repositories

## Benefits

✅ **Database Independent** - Switch databases without code changes
✅ **Clean Architecture** - Separation of concerns
✅ **Testable** - Easy to mock repositories
✅ **Type Safe** - Rust's type system ensures correctness
✅ **Async/Await** - Non-blocking I/O
✅ **CRUD Complete** - All basic operations included

---

Generated by `rvy` - Rust Code Generator
